"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[671],{9881:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=t(7462),l=(t(7294),t(3905));const i={sidebar_position:1,slug:"/"},r="Documentation",s={unversionedId:"intro",id:"intro",title:"Documentation",description:"- Downloaded the necessary libraries",source:"@site/docs/intro.md",sourceDirName:".",slug:"/",permalink:"/Documentation/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,slug:"/"},sidebar:"tutorialSidebar"},o={},p=[{value:"Downloading the dataset",id:"downloading-the-dataset",level:2},{value:"Unmasked images",id:"unmasked-images",level:2},{value:"1. Creating dataset",id:"1-creating-dataset",level:3},{value:"2. Visualising data",id:"2-visualising-data",level:3},{value:"3. Preprocessing",id:"3-preprocessing",level:3},{value:"4. Splitting data",id:"4-splitting-data",level:3},{value:"5. Classification",id:"5-classification",level:3},{value:"A. Simple models",id:"a-simple-models",level:4},{value:"B. Deep Learning Models",id:"b-deep-learning-models",level:4},{value:"Comparison (Masked vs Unmasked)",id:"comparison-masked-vs-unmasked",level:2}],m={toc:p},c="wrapper";function d(e){let{components:a,...t}=e;return(0,l.kt)(c,(0,n.Z)({},m,t,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"documentation"},"Documentation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"import os\nimport numpy as np\nimport pandas as pd \nimport random\nimport cv2\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport tensorflow as tf\nimport seaborn as sns\nfrom tqdm import tqdm\nfrom sklearn.decomposition import PCA\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import accuracy_score, f1_score, roc_auc_score\nfrom sklearn.metrics import classification_report\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier\nfrom matplotlib import pyplot\nfrom sklearn.metrics import roc_curve\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.pipeline import make_pipeline\nfrom xgboost.sklearn import XGBClassifier\nfrom lightgbm import LGBMClassifier\nimport tensorflow as tf\nfrom tensorflow import keras\nfrom keras import layers\nfrom keras.applications import MobileNet\nfrom keras.layers import GlobalAveragePooling2D, Dense\nfrom keras.models import Model\nfrom keras.applications.mobilenet import MobileNet, preprocess_input\nfrom keras.layers import GlobalAveragePooling2D, Dense\nfrom keras.applications.efficientnet import EfficientNetB0, preprocess_input\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Downloaded the necessary libraries")),(0,l.kt)("h2",{id:"downloading-the-dataset"},"Downloading the dataset"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'os.environ["KAGGLE_USERNAME"]="arunraghav"\nos.environ["KAGGLE_KEY"]="7296577ea3df743997bf9f2324653c4c"\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Set the Kaggle username and API key as environment variables")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"!kaggle datasets download tawsifurrahman/covid19-radiography-database\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Downloaded dataset using Kaggle API")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"!unzip covid19-radiography-database\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Extracted all the files in the zip file")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'# import shutil\n# dir_path = "COVID-19_Radiography_Dataset"\n\n# # Use the os module to delete the directory\n# if os.path.exists(dir_path):\n#     shutil.rmtree(dir_path)\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Deleted the directory before re-downloading")),(0,l.kt)("h2",{id:"unmasked-images"},"Unmasked images"),(0,l.kt)("h3",{id:"1-creating-dataset"},"1. Creating dataset"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'covid_images = "COVID-19_Radiography_Dataset/COVID/images/"\ncovid_path= "COVID-19_Radiography_Dataset/COVID/"\nnormal_images = "COVID-19_Radiography_Dataset/Normal/images/"\nnormal_path= "COVID-19_Radiography_Dataset/Normal/"\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"File paths used to access image data in a dataset containing chest X-ray images"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},'"covid_images"')," and ",(0,l.kt)("strong",{parentName:"li"},'"normal_images"')," used to access images under ",(0,l.kt)("strong",{parentName:"li"},'"COVID"')," and ",(0,l.kt)("strong",{parentName:"li"},'"Normal"')," directories"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},'"covid_path"')," and ",(0,l.kt)("strong",{parentName:"li"},'"normal_path"')," used to access the entire sub-directories containing the image files")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'covid_mask = "COVID-19_Radiography_Dataset/COVID/masks/"\ncovid_masked_images="COVID-19_Radiography_Dataset/COVID/covid_masked_images/"\nnormal_mask = "COVID-19_Radiography_Dataset/Normal/masks/"\nnormal_masked_images="COVID-19_Radiography_Dataset/Normal/normal_masked_images/"\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},'"covid_mask"')," and ",(0,l.kt)("strong",{parentName:"li"},'"normal_mask"')," are paths to binary masks that highlight the lung regions of the chest X-ray images"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},'"covid_masked_images"')," and ",(0,l.kt)("strong",{parentName:"li"},'"normal_masked_images"')," used to access images")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"original_files = os.listdir(covid_images)\nmask_files = os.listdir(covid_mask)\nvalid_files = []\nfor filename in original_files:\n    if filename in mask_files:\n        valid_files.append(filename)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'os.listdir()'")," is used to obtain the list of filenames in the directories specified by the variables covid_images and covid_mask"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'valid_files'")," is initialized as an empty list, which will contain the filenames of the images that have a corresponding mask"),(0,l.kt)("li",{parentName:"ul"},"Iterated over the filenames in the ",(0,l.kt)("strong",{parentName:"li"},"'original_files'")," to check if it is also present in ",(0,l.kt)("strong",{parentName:"li"},"'mask_files'"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'if not os.path.exists(covid_path + "covid_masked_images"):\n    os.mkdir(covid_path + "covid_masked_images")\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'os.path.exists()'")," is used to check if the directory exists"),(0,l.kt)("li",{parentName:"ul"},"If False, ",(0,l.kt)("strong",{parentName:"li"},"'os.mkdir()'")," is used to create the directory")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'# Loop through images in COVID original directory\nfor filename in valid_files:\n    # Check if file is an image\n    if filename.endswith(".jpg") or filename.endswith(".png"):\n        # Load original image and corresponding mask\n        original_img = cv2.imread(covid_images + filename)\n        mask_img = cv2.imread(covid_mask + filename)\n\n        # Resize mask image to match dimensions of original image\n        mask_img = cv2.resize(mask_img, (original_img.shape[1], original_img.shape[0]))\n\n        # Convert mask to grayscale\n        mask_gray = cv2.cvtColor(mask_img, cv2.COLOR_BGR2GRAY)\n\n        # Apply mask to original image\n        masked_img = cv2.bitwise_and(original_img, original_img, mask=mask_gray)\n\n        # Save the masked image in the new directory\n        cv2.imwrite(covid_path + "covid_masked_images/" + filename, masked_img)\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'cv2.bitwise_and()'")," used to apply the grayscale mask to the original chest X-ray image, resulting in a masked image where the affected regions due to COVID-19 are isolated")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'if not os.path.exists(normal_path + "normal_masked_images"):\n    os.mkdir(normal_path + "normal_masked_images")\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'os.path.exists()'")," is used to check if the directory exists"),(0,l.kt)("li",{parentName:"ul"},"If False, ",(0,l.kt)("strong",{parentName:"li"},"'os.mkdir()'")," is used to create the directory")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"original_files = os.listdir(normal_images)\nmask_files = os.listdir(normal_mask)\nvalid_files = []\nfor filename in original_files:\n    if filename in mask_files:\n        valid_files.append(filename)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'os.listdir()'")," is used to obtain the list of filenames in the directories specified by the variables normal_images and normal_mask"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'valid_files'")," is initialized as an empty list, which will contain the filenames of the images that have a corresponding mask"),(0,l.kt)("li",{parentName:"ul"},"Iterated over the filenames in the ",(0,l.kt)("strong",{parentName:"li"},"'original_files'")," to check if it is also present in ",(0,l.kt)("strong",{parentName:"li"},"'mask_files'"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'# Loop through images in COVID original directory\nfor filename in valid_files:\n    # Check if file is an image\n    if filename.endswith(".jpg") or filename.endswith(".png"):\n        # Load original image and corresponding mask\n        original_img = cv2.imread(normal_images + filename)\n        mask_img = cv2.imread(normal_mask + filename)\n\n        # Resize mask image to match dimensions of original image\n        mask_img = cv2.resize(mask_img, (original_img.shape[1], original_img.shape[0]))\n\n        # Convert mask to grayscale\n        mask_gray = cv2.cvtColor(mask_img, cv2.COLOR_BGR2GRAY)\n\n        # Apply mask to original image\n        masked_img = cv2.bitwise_and(original_img, original_img, mask=mask_gray)\n\n        # Save the masked image in the new directory\n        cv2.imwrite(normal_path + "normal_masked_images/" + filename, masked_img)\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'cv2.bitwise_and()'")," used to apply the grayscale mask to the original chest X-ray image, resulting in a masked image where the healthy regions of normal lungs are isolated")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'new_original_dataset="COVID-19_Radiography_Dataset/"+ "Dataset"\nnew_covid="COVID-19_Radiography_Dataset/Dataset/"+ "covid"\nnew_non_covid="COVID-19_Radiography_Dataset/Dataset/"+ "non-covid"\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'new_original_dataset'")," specifies the path to the new directory that will contain the preprocessed images"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'new_original_dataset'")," specifies the path to the new directory that will contain the preprocessed images")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"import shutil\n\nif not os.path.exists(new_original_dataset):\n    os.mkdir(new_original_dataset)\nif not os.path.exists(new_covid):\n    os.mkdir(new_covid)\nif not os.path.exists(new_non_covid):\n    os.mkdir(new_non_covid)\n\nold_path1 = covid_images\nold_path2 = normal_images\n\nnew_path1 = new_covid\nnew_path2 = new_non_covid\n\nshutil.move(old_path1, new_path1)\nshutil.move(old_path2, new_path2)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Moved the preprocessed chest X-ray images from the original directories to the new directories created in the previous step"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'shutil.move()'")," function is used to move the contents")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'folder_a_path = new_covid\nfolder_b_path = new_covid+"/images"\nfor file_name in os.listdir(folder_b_path):\n    file_path = os.path.join(folder_b_path, file_name)\n    shutil.move(file_path, folder_a_path)\nshutil.rmtree(folder_b_path)\n\nfolder_a_path = new_non_covid\nfolder_b_path = folder_a_path+"/images"\nfor file_name in os.listdir(folder_b_path):\n    file_path = os.path.join(folder_b_path, file_name)\n    shutil.move(file_path, folder_a_path)\nshutil.rmtree(folder_b_path)\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Moved all images from subdirectories to their parent directories and then deleted the subdirectories")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"folder_path = new_non_covid \nnum_to_delete = 6000\nfile_list = os.listdir(folder_path)\nrandom.shuffle(file_list)\n\nfor i in range(num_to_delete):\n    os.remove(os.path.join(folder_path, file_list[i]))\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Deleted 6000 images from normal directory to balance the dataset"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'os.remove()'")," function is used to delete each file from the directory")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"train_ds = tf.keras.utils.image_dataset_from_directory(\n  new_original_dataset,\n  validation_split=0.2,\n  subset=\"training\",\n  color_mode='grayscale',\n  seed=0,\n  image_size=(224, 224))\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Created a TensorFlow image dataset from a directory"),(0,l.kt)("li",{parentName:"ul"},"Used 20% images for validation"),(0,l.kt)("li",{parentName:"ul"},"Converted to grayscale")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"val_ds = tf.keras.utils.image_dataset_from_directory(\n  new_original_dataset,\n  validation_split=0.2,\n  subset=\"validation\",\n  color_mode='grayscale',\n  seed=0,\n  image_size=(224, 224))\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Created validation dataset"),(0,l.kt)("li",{parentName:"ul"},"Converted to grayscale")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"train_ds_rgb = tf.keras.utils.image_dataset_from_directory(\n  new_original_dataset,\n  validation_split=0.2,\n  subset=\"training\",\n  color_mode='rgb',\n  seed=0,\n  image_size=(224, 224))\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Converted images to rgb")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"val_ds_rgb = tf.keras.utils.image_dataset_from_directory(\n  new_original_dataset,\n  validation_split=0.2,\n  subset=\"validation\",\n  color_mode='rgb',\n  seed=0,\n  image_size=(224, 224))\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Converted images to rgb")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"class_names = train_ds.class_names\nclass_names\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed class_names")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dic={}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'c=0\nlst=list(os.listdir(new_covid))\nfor i in tqdm(range(len(list(os.listdir(new_covid))))):\n  dic[c]=new_covid+"/"+lst[i]\n  c+=1\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Created a list of file paths for the images in the COVID-19 dataset"),(0,l.kt)("li",{parentName:"ul"},"For each filename in the list, appended the path to that file to the dictionary dic with the key as the current value of c"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'tqdm'")," function is used to display a progress bar while the loop is running")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dic_no_covid={}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'c=0\nlst=list(os.listdir(new_non_covid))\nfor i in tqdm(range(len(list(os.listdir(new_non_covid))))):\n  dic_no_covid[c]=new_non_covid+"/"+lst[i]\n  c+=1\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Created a list of file paths for the images in the normal dataset"),(0,l.kt)("li",{parentName:"ul"},"For each filename in the list, appended the path to that file to the dictionary dic with the key as the current value of c"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"'tqdm'")," function is used to display a progress bar while the loop is running")),(0,l.kt)("h3",{id:"2-visualising-data"},"2. Visualising data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.bar(['covid','non-covid'], [4043,5492], color='black')\nplt.xlabel('Class')\nplt.ylabel('Data')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted counts of covid and non-covid images")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'import matplotlib.pyplot as plt\nplt.figure(figsize=(10, 10))\nfor images, labels in train_ds.take(1):\n  for i in range(9):\n    ax = plt.subplot(3, 3, i + 1)\n    plt.imshow(images[i].numpy().reshape(224,224).astype("uint8"), cmap=\'gray\')\n    plt.title(class_names[labels[i]])\n    plt.axis("off")\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted images with their corresponding labels"),(0,l.kt)("li",{parentName:"ul"},"Selected a batch of images and their corresponding labels from ",(0,l.kt)("strong",{parentName:"li"},"'train_ds'")," using the ",(0,l.kt)("strong",{parentName:"li"},"'take()'")," method"),(0,l.kt)("li",{parentName:"ul"},"Then, looped through the first 9 images in the batch and displayed it")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"images = train_ds.take(1)\nfor image, label in images:\n  print('Label:', label.numpy())\n  print('Shape of the batch : {}'.format(image.numpy().shape))\n  print('Dimension of Image : {}'.format(image.ndim))\n  print('Image Data Type : {}'.format(image.dtype))\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed information about the batch of images and labels from ",(0,l.kt)("strong",{parentName:"li"},"'train_ds'")," dataset")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.imshow(image[0, :, :, 0])\nplt.show()\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Displayed the first image from the batch")),(0,l.kt)("h3",{id:"3-preprocessing"},"3. Preprocessing"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"img_path = dic_no_covid[0]\nimg = cv2.imread(img_path)\nimg = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nplt.imshow(img,cmap='gray')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Selected an image from non-covid dictionary and converted it to grayscale")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"n_components_range = range(5, 41, 7)\ncumulative_var = np.zeros(len(n_components_range))\n\nfor i, n_components in enumerate(n_components_range):\n  pca = PCA(n_components=n_components)\n  pca.fit(img)\n  cumulative_var[i] = np.sum(pca.explained_variance_ratio_)\n\nplt.plot(n_components_range, cumulative_var)\nplt.xlabel('Number of Components')\nplt.ylabel('Cumulative Explained Variance')\nplt.show()\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Applied ",(0,l.kt)("strong",{parentName:"li"},"PCA")," on the image with various values of n_components to get optimal value"),(0,l.kt)("li",{parentName:"ul"},"Choosing n_components = 20")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dic_keys=list(dic.keys())\narray_covid=np.zeros((1, 4481))          #(224*20)\nfor i in tqdm(range(len(dic_keys))):\n  img = cv2.imread(dic[i])\n  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n  img = cv2.resize(img, dsize=(224,224))\n  pca = PCA(n_components=20)\n  pca.fit(img)\n  trans_img = pca.transform(img)\n  array_covid = np.append(array_covid,np.concatenate((trans_img.flatten(),np.array([1])),axis=0).reshape(1, 4481),axis=0)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Applied ",(0,l.kt)("strong",{parentName:"li"},"PCA")," on the whole dataset with n_components = 20"),(0,l.kt)("li",{parentName:"ul"},"First resized the images to (224, 224)"),(0,l.kt)("li",{parentName:"ul"},"Concatenated the ",(0,l.kt)("strong",{parentName:"li"},"label 1")," to the covid array")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"dic_no_covid_keys=list(dic_no_covid.keys())\narray_no_covid=np.zeros((1, 4481))\nfor i in tqdm(range(len(dic_no_covid_keys))):\n  img = cv2.imread(dic_no_covid[i])\n  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n  img = cv2.resize(img, dsize=(224,224))\n  pca = PCA(n_components=20)\n  pca.fit(img)\n  trans_img = pca.transform(img)\n  array_no_covid=np.append(array_no_covid,np.concatenate((trans_img.flatten(),np.array([0])),axis=0).reshape(1, 4481),axis=0)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Applied ",(0,l.kt)("strong",{parentName:"li"},"PCA")," on the whole dataset with n_components = 20"),(0,l.kt)("li",{parentName:"ul"},"First resized the images to (224, 224)"),(0,l.kt)("li",{parentName:"ul"},"Concatenated the ",(0,l.kt)("strong",{parentName:"li"},"label 0")," to the non-covid array")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"data_array=np.concatenate((array_covid,array_no_covid),axis=0)\ndata_array.shape\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"(7810, 4481)")),(0,l.kt)("h3",{id:"4-splitting-data"},"4. Splitting data"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"X = data_array.T[:-1].T\nY = data_array.T[-1].T\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Split the data into X and y")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"from sklearn.model_selection import train_test_split as tts\nX_train, X_test, y_train, y_test = tts(X, Y, train_size=0.7)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Split X and y into train-test sets using ",(0,l.kt)("strong",{parentName:"li"},"train_test_split"))),(0,l.kt)("h3",{id:"5-classification"},"5. Classification"),(0,l.kt)("h4",{id:"a-simple-models"},"A. Simple models"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Kmeans")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model1 = KMeans(n_clusters=2, init='k-means++', max_iter=100, n_init=10)\nmodel1.fit(X_train)\ny_pred_kmeans = model1.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"Kmeans")," with n_cluster=2, max_iter=100, n_init=10")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_kmeans = accuracy_score(y_pred_kmeans,y_test)\nprint(f"Accuracy : {(acc_kmeans*100):.2f}%")\nprint()\nprint(classification_report(y_pred_kmeans,y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Decision Tree")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model2 = DecisionTreeClassifier(max_depth=8, min_samples_leaf=2, min_samples_split=3)\nmodel2.fit(X_train, y_train)\ny_pred_dtc = model2.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"Decision Tree")," with max_depth=8, min_samples_leaf=2, min_samples_split=3")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_dtc = accuracy_score(y_pred_dtc, y_test)\nprint(f"Accuracy : {(acc_dtc*100):.2f}%")\nprint()\nprint(classification_report(y_pred_dtc, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"parameters = {'max_depth':[2, 4, 8], 'min_samples_leaf':[2, 4, 7]}\ndtc = DecisionTreeClassifier()\nmodel3 = GridSearchCV(dtc, parameters)\nmodel3.fit(X_train, y_train)\ny_pred_3 = model3.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Performed GridSearchCV using max_depth':","[2, 4, 8]"," and min_samples_leaf':","[2, 4, 7]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model3.best_params_\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the best parameters with highest accuracy")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_3 = accuracy_score(y_pred_3, y_test)\nprint(f"Accuracy : {(acc_3*100):.2f}%")\nprint()\nprint(classification_report(y_pred_3, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model4 = RandomForestClassifier(n_estimators=200, max_depth=8, min_samples_leaf=2, min_samples_split=3)\nmodel4.fit(X_train,y_train)\ny_pred_rfc = model4.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"Random Forest")," with n_estimators=200, max_depth=8, min_samples_leaf=2, min_samples_split=3")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_rfc = accuracy_score(y_pred_rfc, y_test)\nprint(f"Accuracy : {(acc_rfc*100):.2f}%")\nprint()\nprint(classification_report(y_pred_rfc, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"y_pred_rfc_proba = model4.predict_proba(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Predicion prob of each class")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"probs = y_pred_rfc_proba[:, 1]\nfpr, tpr, _ = roc_curve(y_test, probs)\n\npyplot.plot(fpr, tpr, label='RFC')\npyplot.plot([0, 1], [0, 1], linestyle='--', label='Random Guess')\npyplot.xlabel('False Positive Rate')\npyplot.ylabel('True Positive Rate')\npyplot.legend()\npyplot.show()\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted the ",(0,l.kt)("strong",{parentName:"li"},"ROC curve")," for random forest classifier")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"parameters = {'max_depth':[2, 4, 8], 'min_samples_leaf':[2, 4, 7]}\nrfc = RandomForestClassifier()\nmodel5 = GridSearchCV(rfc, parameters)\nmodel5.fit(X_train, y_train)\ny_pred_5 = model5.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Performed GridSearchCV using max_depth':","[2, 4, 8]"," and min_samples_leaf':","[2, 4, 7]")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model5.best_score_\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the highest accuracy obtained")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_5 = accuracy_score(y_pred_5, y_test)\nprint(f"Accuracy : {(acc_5*100):.2f}%")\nprint()\nprint(classification_report(y_pred_5, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Logistic Regression")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model6 = LogisticRegression()\nmodel6.fit(X_train, y_train)\ny_pred_lgr = model6.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"Logistic Regression"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_lgr = accuracy_score(y_pred_lgr, y_test)\nprint(f"Accuracy : {(acc_lgr*100):.2f}%")\nprint()\nprint(classification_report(y_pred_lgr, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"SVM")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model7 = make_pipeline(StandardScaler(), SVC())\nmodel7.fit(X_train, y_train)\ny_pred_svm = model7.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"SVM classifier")," by making a pipleline with StandardScaler")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_svm = accuracy_score(y_pred_svm, y_test)\nprint(f"Accuracy : {(acc_svm*100):.2f}%")\nprint()\nprint(classification_report(y_pred_svm, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"XGBoost")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model8 = XGBClassifier(n_estimators=200) \nmodel8.fit(X_train, y_train)\ny_pred_xgb = model8.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"XGBClassifier")," with n_estimators=200")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_xgb = accuracy_score(y_pred_xgb, y_test)\nprint(f"Accuracy : {(acc_xgb*100):.2f}%")\nprint()\nprint(classification_report(y_pred_xgb, y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"LightGBM")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model9 = LGBMClassifier(n_estimators=200)\nmodel9.fit(X_train, y_train)\ny_pred_lgbm = model9.predict(X_test)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained ",(0,l.kt)("strong",{parentName:"li"},"LGBMClassifier")," with n_estimators=200")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'acc_lgbm = accuracy_score(y_pred_lgbm,y_test)\nprint(f"Accuracy : {(acc_lgbm*100):.2f}%")\nprint()\nprint(classification_report(y_pred_lgbm,y_test))\n')),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Printed the accuracy and classification report")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Comparing")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(['KMeans', 'DTC', 'RFC', 'LR', 'SVM', 'XGBC','LGBMC'], [acc_kmeans, acc_dtc, acc_rfc, acc_lgr, acc_svm, acc_xgb, acc_lgbm], marker='o', color='black')\nplt.xlabel('Model')\nplt.ylabel('Accuracy')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted a line to compare accuracies of all the above models")),(0,l.kt)("h4",{id:"b-deep-learning-models"},"B. Deep Learning Models"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Simple CNN")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model = tf.keras.Sequential([\n  layers.Conv2D(32, 3, activation='relu', input_shape=(224, 224, 1)),\n  layers.MaxPooling2D(),\n  layers.Conv2D(64, 3, activation='relu'),\n  layers.MaxPooling2D(),\n  layers.Conv2D(128, 3, activation='relu'),\n  layers.MaxPooling2D(),\n  layers.Flatten(),\n  layers.Dense(64, activation='relu'),\n  layers.Dense(1, activation='sigmoid')\n])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Sequential model in Keras"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Conv2D")," layer with 32 filters, a kernel size of 3x3, and a ReLU activation function. "),(0,l.kt)("li",{parentName:"ul"},"This layer took an input image of size 224x224 with 1 channel (grayscale)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"MaxPooling2D")," layer with a pool size of 2x2"),(0,l.kt)("li",{parentName:"ul"},"This layer reduced the spatial dimensions of the feature maps by half"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Conv2D")," layer with 64 filter"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"MaxPooling2D")," layer with a pool size of 2x2"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Conv2D")," layer with 128 filters"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"MaxPooling2D")," layer with a pool size of 2x2. "),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Flatten")," layer which flattened the feature maps to a 1D vector."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Dense")," layer with 64 units and a ReLU activation function."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Dense")," layer with 1 unit and a sigmoid activation function. "),(0,l.kt)("li",{parentName:"ul"},"This was the output layer which produced a probability score for the input image belonging to the COVID-19 class.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model.compile(\n  optimizer='adam',\n  loss='binary_crossentropy',\n  metrics=['accuracy'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Configured the learning process of a model using ",(0,l.kt)("strong",{parentName:"li"},"'model.compile()'")),(0,l.kt)("li",{parentName:"ul"},"Used adam optimizer, binary_crossentropy as loss function and accuracy for evaluation metrics")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"history = model.fit(\n  train_ds,\n  validation_data=val_ds,\n  epochs=10)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained the model on ",(0,l.kt)("strong",{parentName:"li"},"train_ds")," and validated on ",(0,l.kt)("strong",{parentName:"li"},"val_ds")," for 10 epochs")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"hist_cnn = pd.DataFrame(history.history)\nhist_cnn['epoch'] = history.epoch\nhist_cnn\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"history.history")," is a dictionary that contains the loss and accuracy values during training for each epoch"),(0,l.kt)("li",{parentName:"ul"},"Converted it to pd df"),(0,l.kt)("li",{parentName:"ul"},"Added a new column to the df called ",(0,l.kt)("strong",{parentName:"li"},"epoch"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(hist_cnn['accuracy'], marker='o', color='black')\nplt.xlabel('epochs')\nplt.ylabel('Accuracy')\nplt.title('Accuracy variation with epochs')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted a line to compare accuracies over all the epochs")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"MobileNet")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"import warnings\nwarnings.filterwarnings('ignore')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"To prevent the printing of warnings")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"from keras.applications.mobilenet import MobileNet, preprocess_input\ntrain_ds_rgb_new = train_ds_rgb.map(lambda x, y: (preprocess_input(x), y))\n\nbase_model = MobileNet(weights='imagenet', include_top=False, input_shape=(224, 224, 3))\n\nx = base_model.output\nx = GlobalAveragePooling2D()(x)\npredictions = Dense(2, activation='softmax')(x)\nmodel = Model(inputs=base_model.input, outputs=predictions)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Preprocessed input images according to the preprocessing scheme used by the MobileNet model using ",(0,l.kt)("strong",{parentName:"li"},"preprocess_input")," function"),(0,l.kt)("li",{parentName:"ul"},"Instantiated the MobileNet model with pre-trained ImageNet weights, but with the top (classification) layer removed using ",(0,l.kt)("strong",{parentName:"li"},"include_top=False")),(0,l.kt)("li",{parentName:"ul"},"x equal to the output of the base model"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"GlobalAveragePooling2D")," layer took the feature representation and computed the average of each feature map, resulting in a fixed-length vector"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Dense")," layer with a softmax activation function is added on top of the base model to produce the final output")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Configured the learning process of a model using ",(0,l.kt)("strong",{parentName:"li"},"'model.compile()'")),(0,l.kt)("li",{parentName:"ul"},"Used adam optimizer, sparse_categorical_crossentropy as loss function and accuracy for evaluation metrics")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"history = model.fit(train_ds_rgb_new, epochs=10, validation_data=val_ds_rgb)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained the model on ",(0,l.kt)("strong",{parentName:"li"},"train_ds_rgb_new")," and validated on ",(0,l.kt)("strong",{parentName:"li"},"val_ds_rgb")," for 10 epochs")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"hist_mn = pd.DataFrame(history.history)\nhist_mn['epoch'] = history.epoch\nhist_mn\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"history.history")," is a dictionary that contains the loss and accuracy values during training for each epoch"),(0,l.kt)("li",{parentName:"ul"},"Converted it to pd df"),(0,l.kt)("li",{parentName:"ul"},"Added a new column to the df called ",(0,l.kt)("strong",{parentName:"li"},"epoch"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(hist_mn['accuracy'], marker='o', color='black')\nplt.xlabel('epochs')\nplt.ylabel('Accuracy')\nplt.title('Accuracy variation with epochs')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted a line to compare accuracies over all the epochs")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"EfficientNet")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"from keras.applications.efficientnet import EfficientNetB0, preprocess_input\ntrain_ds_rgb_new = train_ds_rgb.map(lambda x, y: (preprocess_input(x), y))\n\nbase_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))\n\nx = base_model.output\nx = GlobalAveragePooling2D()(x)\npredictions = Dense(2, activation='softmax')(x)\nmodel = Model(inputs=base_model.input, outputs=predictions)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Preprocessed input images according to the preprocessing scheme used by the EfficientNet model using ",(0,l.kt)("strong",{parentName:"li"},"preprocess_input")," function"),(0,l.kt)("li",{parentName:"ul"},"Instantiated the EfficientNet model with pre-trained ImageNet weights, but with the top (classification) layer removed using ",(0,l.kt)("strong",{parentName:"li"},"include_top=False")),(0,l.kt)("li",{parentName:"ul"},"x equal to the output of the base model"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"GlobalAveragePooling2D")," layer took the feature representation and computed the average of each feature map, resulting in a fixed-length vector"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"Dense")," layer with a softmax activation function is added on top of the base model to produce the final output")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"model.compile(optimizer='adam',\n              loss='sparse_categorical_crossentropy',\n              metrics=['accuracy'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Configured the learning process of a model using ",(0,l.kt)("strong",{parentName:"li"},"'model.compile()'")),(0,l.kt)("li",{parentName:"ul"},"Used adam optimizer, sparse_categorical_crossentropy as loss function and accuracy for evaluation metrics")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"history = model.fit(train_ds_rgb_new, epochs=10, validation_data=val_ds_rgb)\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Trained the model on ",(0,l.kt)("strong",{parentName:"li"},"train_ds_rgb_new")," and validated on ",(0,l.kt)("strong",{parentName:"li"},"val_ds_rgb")," for 10 epochs")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"hist_en = pd.DataFrame(history.history)\nhist_en['epoch'] = history.epoch\nhist_en\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"history.history")," is a dictionary that contains the loss and accuracy values during training for each epoch"),(0,l.kt)("li",{parentName:"ul"},"Converted it to pd df"),(0,l.kt)("li",{parentName:"ul"},"Added a new column to the df called ",(0,l.kt)("strong",{parentName:"li"},"epoch"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(hist_en['accuracy'], marker='o', color='black')\nplt.xlabel('epochs')\nplt.ylabel('Accuracy')\nplt.title('Accuracy variation with epochs')\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted a line to compare accuracies over all the epochs")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Carried out the same steps for Unmasked Images dataset")),(0,l.kt)("h2",{id:"comparison-masked-vs-unmasked"},"Comparison (Masked vs Unmasked)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(['KMeans', 'DTC', 'RFC', 'LR', 'SVM', 'XGBC','LGBMC'], [acc_kmeans, acc_dtc, acc_rfc, acc_lgr, acc_svm, acc_xgb, acc_lgbm], marker='o', color='black')\nplt.plot(['KMeans', 'DTC', 'RFC', 'LR', 'SVM', 'XGBC','LGBMC'], [m_acc_kmeans, m_acc_dtc, m_acc_rfc, m_acc_lgr, m_acc_svm, m_acc_xgb, m_acc_lgbm], marker='o', color='orange')\nplt.xlabel('model')\nplt.ylabel('accuracy')\nplt.legend(['UnMasked','Masked'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted line plots to compare accuracies for masked and unmasked datasets for simple models")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(hist_cnn['accuracy'], marker='o', color='black')\nplt.plot(m_hist_cnn['accuracy'], marker='o', color='orange')\nplt.xlabel('epochs')\nplt.ylabel('Accuracy')\nplt.title('Accuracy variation with epochs')\nplt.legend(['Masked','UnMasked'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted line plots to compare accuracies for masked and unmasked datasets for cnn")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(hist_mn['accuracy'], marker='o', color='black')\nplt.plot(m_hist_mn['accuracy'], marker='o', color='orange')\nplt.xlabel('epochs')\nplt.ylabel('Accuracy')\nplt.title('Accuracy variation with epochs')\nplt.legend(['Masked','UnMasked'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted line plots to compare accuracies for masked and unmasked datasets for MobileNet")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"plt.plot(hist_en['accuracy'], marker='o', color='black')\nplt.plot(m_hist_en['accuracy'], marker='o', color='orange')\nplt.xlabel('epochs')\nplt.ylabel('Accuracy')\nplt.title('Accuracy variation with epochs')\nplt.legend(['Masked','UnMasked'])\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Plotted line plots to compare accuracies for masked and unmasked datasets for EfficientNet")))}d.isMDXComponent=!0}}]);